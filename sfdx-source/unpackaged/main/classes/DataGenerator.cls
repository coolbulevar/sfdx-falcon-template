public class DataGenerator {
    /**
     * Custom Exception class.
     */
    private class DataGeneratorException extends UnpackagedException {}
    /**
     * Map of Reference IDs to Record IDs.
     */
    private static Map<String, Id> idMap = new Map<String, Id>();
    /**
     * List of all DataGenerator objects created during the current execution context.
     */
    private static List<DataGenerator> dgList = new List<DataGenerator>();
    /**
     * Global describe to use while this DataGenerator is working.
     */
    private static Map<String, Schema.SObjectType> gDsc = Schema.getGlobalDescribe();
    /** 
     * Indicates whether or not the SObject held by this DataGenerator is read for insertion.
     */
    public Boolean readyForInsert {
        get {
            if (wasInserted) {
                // DataGenerators whose SObject has been
                // inserted are never "ready for insert".
                return false;
            } else {
                return readyForInsert;
            }
        } 
        private set;}
    /** 
     * Indicates whether or not the SObject held by this DataGenerator was inserted.
     */
    private Boolean wasInserted;
    /** 
     * Map representing the JSON Record to be generated by this DataGenerator object. 
     */
    private Map<String, Object> recordMap;
    /**
     * Map representing the Attributes of the JSON Record to be generated by this DataGenerator object.
     */
    private Map<String, Object> attributesMap;
    /**
     * The API Name for the type of SObject represented by this DataGenerator object.
     */
    private String typeName;
    /**
     * The "local" type name of the SObject represented by this DataGenerator object. 
     * Local types do not include a namespace prefix when described by Apex running in
     * the context of the same namespace.
     */
    private String localTypeName;
    /**
     * The Reference ID for the record data provided to DataGenerator constructor.
     */
    private String referenceId;
    /**
     * List of Lookup field keys (i.e. local field names) found within the data provided to the DataGenerator constructor.
     */
    private List<String> localLookupNames {get; private set;}
    /**
     * The SObject created from the JSON data provided to the DataGenerator constructor.
     */
    public SObject sobj {get; private set;}
    /**
     * The Schema for the SObject Type represented by this DataGenerator object.
     */
    private Schema.SObjectType sobjType;
    /**
     * The Field Map for the SObject Type represented by this DataGenerator object.
     */
    private Map<String, Schema.SObjectField> sobjFieldMap;

    /**
     * Constructor for the DataGenerator class.
     * 
     * @param jsonRecord `Object` contains a single JSON data record.
     * @return `DataGenerator`
     * ```
     * DataGenerator dg = new DataGenerator(jsonRecord);
     * ```
     */
    private DataGenerator(Object jsonRecord) {
        // Ensure usable JSON was provided by the caller.
        if (jsonRecord instanceof Map<String, Object>) {
            System.debug(LoggingLevel.INFO, 'DataGenerator jsonRecord: ' + jsonRecord);
            this.recordMap = (Map<String, Object>)jsonRecord;
        } else {
            // The caller did not provide usable JSON.
            String errorMessage = 'The caller did not provide usable JSON.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            System.debug(LoggingLevel.ERROR, 'jsonRecord: ' + jsonRecord);
            throw new DataGeneratorException(errorMessage);
        }
        // Extract the Reference ID and Type Name.
        // 1. Ensure the Record Map has an "attributes" key containing a Map<String, Object>.
        if (this.recordMap.containsKey('attributes') && this.recordMap.get('attributes') instanceof Map<String, Object>){
            this.attributesMap = (Map<String, Object>)this.recordMap.get('attributes');
            // 2. Ensure the Attributes Map has a "type" key containing a non-empty String.
            if (this.attributesMap.containsKey('type') && this.attributesMap.get('type') instanceof String && String.isNotEmpty((String)this.attributesMap.get('type'))) {
                this.localTypeName = (String)this.attributesMap.get('type');
                // 3. Ensure the Attributes Map has a "referenceId" key containing a non-empty String.
                if (this.attributesMap.containsKey('referenceId') && this.attributesMap.get('referenceId') instanceof String && String.isNotEmpty((String)this.attributesMap.get('referenceId'))) {
                    this.referenceId = (String)this.attributesMap.get('referenceId');
                } else {
                    // E3. The Attributes Map does not have a "referenceId" key containing a non-empty String.
                    String errorMessage = 'The Attributes Map does not have a "referenceId" key containing a non-empty String.';
                    System.debug(LoggingLevel.ERROR, errorMessage);
                    System.debug(LoggingLevel.ERROR, 'this.attributesMap: ' + this.attributesMap);
                    throw new DataGeneratorException(errorMessage);
                }
            } else {
                // E2. The Attributes Map does not have a "type" key containing a non-empty String.
                String errorMessage = 'The Attributes Map does not have a "type" key containing a non-empty String.';
                System.debug(LoggingLevel.ERROR, errorMessage);
                System.debug(LoggingLevel.ERROR, 'this.attributesMap: ' + this.attributesMap);
                throw new DataGeneratorException(errorMessage);
            }
        } else {
            // E1. The Record Map does not have an "attributes" key containing a Map<String, Object>.
            String errorMessage = 'The Record Map does not have an "attributes" key containing a Map<String, Object>.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            System.debug(LoggingLevel.ERROR, 'this.recordMap: ' + this.recordMap);
            throw new DataGeneratorException(errorMessage);
        }
        // Initialize all SObject member variables based on the specified Type Name.
        try {
            // Translate local SObject type name to runtime type name.
            this.typeName = DataGenerator.getSObjTypeName(this.localTypeName);
            System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': Matched local SObject type "' + this.localTypeName + '" to "' + this.typeName + '".');

            // Populate remaining SObject-related member variables.
            this.readyForInsert = false;
            this.wasInserted    = false;
            this.sobjType       = DataGenerator.gDsc.get(this.typeName);
            this.sobjFieldMap   = this.sobjType.getDescribe().fields.getMap();
            this.sobj           = this.sobjType.newSObject();
        } catch (Exception e) {
            // Something went wrong trying to create an SObject using the specified Type Name.
            String errorMessage = 'Exception thrown trying to create an SObject using the specified Type Name.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            System.debug(LoggingLevel.ERROR, 'this.typeName: ' + this.typeName);
            System.debug(LoggingLevel.ERROR, 'Exception Message: ' + e.getMessage());
            throw new DataGeneratorException(errorMessage);
        }
        // Initialize member variable collections.
        this.localLookupNames = new List<String>();

        // Populate SObject fields using the data provided by the caller.
        for (String key : this.recordMap.keySet()) {
            // Skip iterations for the "attributes" key.
            if (key == 'attributes') {
                // Move to the next Child Record.
                continue;
            }
            // Create DataGenerator objects for all Child Records found in Keys holding a Map<String, Object>.
            if (this.recordMap.get(key) instanceof Map<String, Object>) {
                List<Object> childRecordList = DataGenerator.getRecordList(this.recordMap.get(key));
                for (Object childRecord : childRecordList) {
                    DataGenerator newDg = new DataGenerator(childRecord);
                    // Add the new DataGenerator to the global DG List
                    // and move to the next Child Record.
                    DataGenerator.dgList.add(newDg);
                    continue;
                }
                // Stop processing this field and move to the next Field.
                continue;
            }
            // Define variables to store fully-qualified Field Name and Type.
            String fieldName;
            String fieldType;

            // Try to match the key to a "local" field name. 
            // Local field names do not include a namespace when
            // the describe call is executed in that namespace.
            for (Schema.SObjectField sobjField : this.sobjFieldMap.values()) {
                Schema.DescribeFieldResult dfr = sobjField.getDescribe();
                if (dfr.getLocalName() == key) {
                    fieldName = dfr.getName();
                    System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': Matched key "' + key + '" to "' + fieldName + '".');
                    break;
                }
            }
            // Ensure that a matching field name was found.
            if (String.isEmpty(fieldName)) {
                String errorMessage = 'DG Object ' + this.referenceId + ': The key "' + key + '" can not be matched to a local field name.';
                System.debug(LoggingLevel.ERROR, errorMessage);
                throw new DataGeneratorException(errorMessage);
            }
            // Populate SObject field values EXCEPT for "REFERENCE" (i.e. Lookup/Master-Detail) fields.
            try {        
                fieldType = String.valueOf(this.sobjFieldMap.get(fieldName).getDescribe().getType());
            } catch (Exception e) {
                String errorMessage = 'Exception thrown while describing the type of the "' + fieldName + '" field.';
                System.debug(LoggingLevel.ERROR, errorMessage);
                System.debug(LoggingLevel.ERROR, 'Caught Exception: ' + e.getMessage());
                throw new DataGeneratorException(errorMessage);
            }
            if (fieldType != 'REFERENCE') {
                this.sobj.put(fieldName, this.recordMap.get(key));
                System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': Set "' + fieldName +'" to -->' + this.sobj.get(key) + '<--');
            } else {
                this.localLookupNames.add(key);
                System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': Reference Field "' + fieldName +'" points to Reference ID -->' + this.recordMap.get(key) + '<--');
                System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': Local Lookup Fields Found: ' + this.localLookupNames);
            }
            // Move to the next Child Record.
            continue;
        }
        // Constructor complete.
        System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': sobj at end of Constructor: ' + this.sobj);
        return;
    }

    /**
     * Prepares the SObject held by this DataGenerator for insertion. The
     * critical part of this process is the attempt match Record IDs to the
     * Reference ID strings currently held in lookup/master-detail fields.
     * ```
     * dg.prepareForInsert();
     * ```
     */
    public void prepareForInsert() {
        // DataGenerators that have already been inserted do not require preparation.
        if (this.wasInserted) {
            System.debug(LoggingLevel.INFO, 'Skipping preparation for "' + this.referenceId + '" because the related SObject was already inserted.');
            return;
        }
        // DataGenerators with no local lookup names do not require preparation.
        if (this.localLookupNames.size() == 0) {
            this.readyForInsert = true;
            System.debug(LoggingLevel.INFO, 'Skipping preparation for "' + this.referenceId + '" because the size of this.localLookupNames is -->' + this.localLookupNames.size() + '<--.');
            return;
        }
        // DataGenerators that are already "ready for insert" do not require preparation.
        if (this.readyForInsert) {
            System.debug(LoggingLevel.INFO, 'Skipping preparation for "' + this.referenceId + '" because the value of this.readyForInsert is -->' + this.readyForInsert + '<--.');
            return;
        }
        System.debug(LoggingLevel.INFO, 'Beginning preparation for "' + this.referenceId + '".');
        // Ensure all lookup fields can be populated.
        for (String localLookupName : this.localLookupNames) {
            String lookupRefId = (String)(this.recordMap.get(localLookupName));
            if (DataGenerator.idMap.containsKey(lookupRefId)) {
                Id lookupValue = DataGenerator.idMap.get(lookupRefId);
                System.debug(LoggingLevel.INFO, 'During preparation of "' + this.referenceId + '" the lookupRefId "' + lookupRefId + '" was matched to Record ID "' + lookupValue + '".');
                setFieldValue(localLookupName, lookupValue);
                continue;
            }
            else {
                // This DataGenerator has at least one lookup field that can not
                // yet be populated with a Record ID. Exit without marking this
                // DataGenerator as being "ready for insert".
                System.debug(LoggingLevel.INFO, 'During preparation of "' + this.referenceId + '" the lookupRefId  "' + lookupRefId + '" could not be matched to Record ID. This DataGenerator is NOT "ready for insertion".');
                return;
            }
        }
        // All lookup fields have been populated with Record IDs.
        // We may now mark this DataGenerator as "ready for insert".
        this.readyForInsert = true;
        System.debug(LoggingLevel.INFO, 'DataGenerator "' + this.referenceId + '" is ready for insertion.');
        return;
    }

    /**
     * Sets a field value on the SObject held by this DataGenerator given a
     * "local" (i.e. non-namespaced) field name and a value for that field.
     * This method will automatically convert the local field name to the
     * full API name used in the runtime environment.
     * 
     * @param localFieldName `String` The local (i.e. non-namespaced) name of
     * the field whose value is being set.
     * @param fieldValue `Object` The value to set the specified field to.
     * ```
     * dg.setFieldValue('BusinessPhone', '555-123-4567');
     * ```
     */
    private void setFieldValue(String localFieldName, Object fieldValue) {
        String fieldName;
        for (Schema.SObjectField sobjField : this.sobjFieldMap.values()) {
            Schema.DescribeFieldResult dfr = sobjField.getDescribe();
            if (dfr.getLocalName() == localFieldName) {
                fieldName = dfr.getName();
                System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': Matched local field name "' + localFieldName + '" to runtime field name "' + fieldName + '".');
                break;
            }
        }
        // Ensure a matching field name was found.
        if (String.isEmpty(fieldName)) {
            String errorMessage = 'DG Object ' + this.referenceId + ': The name "' + localFieldName + '" can not be matched to a local field name.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            throw new DataGeneratorException(errorMessage);
        }
        // Set the field value.
        this.sobj.put(fieldName, fieldValue);
        System.debug(LoggingLevel.INFO, 'DG Object ' + this.referenceId + ': Set "' + fieldName +'" to -->' + fieldValue + '<--');
        return;
    }

    /**
     * After the SObject held by this DataGenerator has been inserted, registers
     * the resulting Record ID by adding to the idMap static variable. This way
     * the Record ID is available when child objects are prepared for insertion.
     * ```
     * dg.registerRecordId();
     * ```
     */
    public void registerRecordId() {
        // Ensure the Reference ID for this DataGenerator is unique.
        if (DataGenerator.idMap.containsKey(this.referenceId)) {
            String errorMessage = 'DG Object ' + this.referenceId + ': The Reference ID  "' + this.referenceId + '" is already in use. Please ensure that all JSON records have unique Reference IDs.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            throw new DataGeneratorException(errorMessage);
        } else {
            // Ensure the SObject record has a Record ID.
            if (this.sobj.Id == null) {
                String errorMessage = 'DG Object ' + this.referenceId + ': The attached SObject does not yet have a Record ID.';
                System.debug(LoggingLevel.ERROR, errorMessage);
                throw new DataGeneratorException(errorMessage);    
            } else {
                // Put this combination of Reference ID and Record ID in the static
                // ID Map, then mark this DataGenerator as having been inserted.
                DataGenerator.idMap.put(this.referenceId, this.sobj.Id);
                this.wasInserted = true;
                return;
            }
        }
    }

    /**
     * Reads SObject records represented as JSON Data and
     * prepares DataGenerator objects for each record found.
     * 
     * @param jsonData `Object` contains a validated JSON data map.
     * @return `void`
     * ```
     * DataGenerator.readJsonData(jsonData);
     * ```
     */
    public static void readJsonData(Object jsonData) {
        // Validate the entire datamap provided by the caller.
        validateDataMap(jsonData);
        // Get the top-level records from the JSON Data.
        List<Object> jsonRecordList = getRecordList(jsonData);
        // Create DataGenerator objects for top-level records. 
        for (Object jsonRecord : jsonRecordList) {
            DataGenerator newDg = new DataGenerator(jsonRecord);
            // Add the new DataGenerator to the global DG List.
            DataGenerator.dgList.add(newDg);
        }
    }

    /**
     * Validates JSON data imported from a file and ensures that
     * all "record" objects have an "attributes" object with "type"
     * and "referenceId" properties.
     * 
     * @param jsonData `Object` contains a JSON data map.
     * @return `void`
     * ```
     * DataGenerator.validateDataMap(jsonData);
     * ```
     */
    private static void validateDataMap(Object jsonData) {
        // 1. Ensure usable JSON was provided by the caller.
        if (jsonData instanceof Map<String, Object>) {
            // 2. Ensure the JSON provided by the caller has a "records" key containing a List<Object>.
            Map<String, Object> dataMap = (Map<String, Object>)jsonData;
            if (dataMap.containsKey('records') && dataMap.get('records') instanceof List<Object>) {
                // Iterate over the List of records.
                List<Object> recordsList = (List<Object>)dataMap.get('records');
                for (Object record : recordsList) {
                    // 3. Ensure the record is a JSON object (i.e. an instance of Map<String, Object>).
                    if (record instanceof Map<String, Object>) {
                        // 4. Ensure the record has an "attributes" key containing a Map<String, Object>.
                        Map<String, Object> recordMap = (Map<String, Object>)record;
                        if (recordMap.containsKey('attributes') && recordMap.get('attributes') instanceof Map<String, Object>) {
                            // 5. Ensure the attributes map has a "type" key containing a non-empty String.
                            Map<String, Object> attributesMap = (Map<String, Object>)recordMap.get('attributes');
                            if (attributesMap.containsKey('type') && attributesMap.get('type') instanceof String && String.isNotEmpty((String)attributesMap.get('type'))) {
                                // 6. Ensure the attributes map has a "referenceId" key containing a non-empty String.
                                if (attributesMap.containsKey('referenceId') && attributesMap.get('referenceId') instanceof String && String.isNotEmpty((String)attributesMap.get('referenceId'))) {
                                    // Iterate over the List of fields.
                                    for (String key : recordMap.keySet()) {
                                        // 7. Validate any Object values, excluding the 'attributes' key.
                                        if (key != 'attributes' && recordMap.get(key) instanceof Map<String, Object>) {
                                            validateDataMap(recordMap.get(key));
                                        } 
                                    }
                                } else {
                                    // E6. The attributes object does not have a "referenceId" key containing a non-empty String.
                                    String errorMessage = 'The attributes object does not have a "referenceId" key containing a non-empty String.';
                                    System.debug(LoggingLevel.ERROR, errorMessage);
                                    System.debug(LoggingLevel.ERROR, 'attributesMap: ' + attributesMap);
                                    throw new DataGeneratorException(errorMessage);
                                }
                            } else {
                                // E5. The attributes object does not have a "type" key containing a non-empty String.
                                String errorMessage = 'The attributes object does not have a "type" key containing a non-empty String.';
                                System.debug(LoggingLevel.ERROR, errorMessage);
                                System.debug(LoggingLevel.ERROR, 'attributesMap: ' + attributesMap);
                                throw new DataGeneratorException(errorMessage);
                            }
                        } else {
                            // E4. The record object does not have an "attributes" key containing a Map<String, Object>.
                            String errorMessage = 'The record object does not have an "attributes" key containing a Map<String, Object>.';
                            System.debug(LoggingLevel.ERROR, errorMessage);
                            System.debug(LoggingLevel.ERROR, 'recordMap: ' + recordMap);
                            throw new DataGeneratorException(errorMessage);
                        }
                    } else {
                        // E3. The record is not a JSON object because it is not an instance of Map<String, Object>.
                        String errorMessage = 'The record is not a JSON object because it is not an instance of Map<String, Object>.';
                        System.debug(LoggingLevel.ERROR, errorMessage);
                        System.debug(LoggingLevel.ERROR, 'record: ' + record);
                        throw new DataGeneratorException(errorMessage);
                    }
                }
            } else {
                // E2. The JSON provided by the caller does not have a "records" key containing a List<Object>.
                String errorMessage = 'The JSON provided by the caller does not have a "records" key containing a List<Object>.';
                System.debug(LoggingLevel.ERROR, errorMessage);
                System.debug(LoggingLevel.ERROR, 'dataMap: ' + dataMap);
                throw new DataGeneratorException(errorMessage);
             }
        } else {
            // E1. The caller did not provide usable JSON.
            String errorMessage = 'The caller did not provide usable JSON.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            System.debug(LoggingLevel.ERROR, 'jsonData: ' + jsonData);
            throw new DataGeneratorException(errorMessage);
        }
    }

    /**
     * Extracts a list of JSON record objects from the specified JSON.
     * 
     * @param jsonData `Object` contains a JSON "records" array.
     * @return `List<Object>` contains individual JSON record objects.
     * ```
     * List<Object> recordList = DataGenerator.getRecordList(jsonData);
     * ```
     */
    private static List<Object> getRecordList(Object jsonData) {
        // 1. Ensure usable JSON was provided by the caller.
        if (jsonData instanceof Map<String, Object>) {
            // 2. Ensure the JSON Data Map has a "records" key containing a List<Object>.
            Map<String, Object> jsonDataMap = (Map<String, Object>)jsonData;
            if (jsonDataMap.containsKey('records') && jsonDataMap.get('records') instanceof List<Object>) {
                // Return the Record List.
                return (List<Object>)jsonDataMap.get('records');
            } else {
                // E2. The JSON Data Map does not have a "records" key containing a List<Object>.
                String errorMessage = 'The JSON Data Map does not have a "records" key containing a List<Object>.';
                System.debug(LoggingLevel.ERROR, errorMessage);
                System.debug(LoggingLevel.ERROR, 'jsonDataMap: ' + jsonDataMap);
                throw new DataGeneratorException(errorMessage);
            }
        } else {
            // E1. The JSON provided by the caller is invalid because it is not an instance of Map<String, Object>.
            String errorMessage = 'The JSON provided by the caller is invalid because it is not an instance of Map<String, Object>.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            System.debug(LoggingLevel.ERROR, 'jsonData: ' + jsonData);
            throw new DataGeneratorException(errorMessage);
        }
    }

    /**
     * Translates a local type name for an SObject to a runtime API type name.
     * 
     * @param localTypeName `String` A local (i.e. non-namespaced) type name.
     * @return `String` The runtime (i.e. namespaced) API type name for the local type name.
     * ```
     * String typeName = DataGenerator.getSObjTypeName(localTypeName);
     * ```
     */
    private static String getSObjTypeName(String localTypeName) {
        String typeName;
        try {
            for (Schema.SObjectType sobjType : DataGenerator.gDsc.values()) {
                Schema.DescribeSObjectResult dor = sobjType.getDescribe();
                if (dor.getLocalName() == localTypeName) {
                    typeName = dor.getName();
                    System.debug(LoggingLevel.INFO, 'UTILITY: SObject type name "' + typeName + '" matched to local type name "' + localTypeName + '".');
                    return typeName;
                }
            }
            // The specified SObject local type name did not match any SObject types in the runtime environment.
            String errorMessage = 'The specified SObject local type name did not match any SObject types in the runtime environment.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            System.debug(LoggingLevel.ERROR, 'localTypeName: ' + localTypeName);
            throw new DataGeneratorException(errorMessage);
        } catch (Exception e) {
            // Exception thrown while trying to get a runtime SObject type name from a local type name.
            String errorMessage = 'Exception thrown while trying to get a runtime SObject type name from a local type name.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            System.debug(LoggingLevel.ERROR, 'localTypeName: ' + localTypeName);
            System.debug(LoggingLevel.ERROR, 'Exception Message: ' + e.getMessage());
            throw new DataGeneratorException(errorMessage);
        }
    }

    /**
     * Inserts SObject records of the specified object type as long as 
     * all lookup fields for the specified records have been populated.
     * Records without all lookup fields populated are skipped.
     * 
     * @param localTypeName `String` The local (i.e. non-namespaced) type
     * name whose records will be inserted.
     * @return `List<Database.SaveResult>` The result of an INSERT operation.
     * ```
     * List<Database.SaveResult> sr = DataGenerator.insertRecords('Account');
     * ```
     */
    public static List<Database.SaveResult> insertRecords(String localTypeName) {
        System.debug(LoggingLevel.INFO, 'Begin insertRecords for SObject local type name "' + localTypeName + '".');
        // 1. Ensure an Object Type was provided by the caller.
        if (String.isNotBlank(localTypeName)) {
            // Translate local SObject type name to runtime type name.
            String typeName = DataGenerator.getSObjTypeName(localTypeName);

            // Build a list of Data Generators and SObjects for insertion.
            List<DataGenerator> dgsForInsertion      = new List<DataGenerator>();
            List<SObject>       sObjectsForInsertion = new List<SObject>();
            for (DataGenerator dg : DataGenerator.dgList) {
                if (dg.typeName == typeName) {
                    dg.prepareForInsert();
                    System.debug(LoggingLevel.INFO, 'Just prepared "' + dg.referenceId + '" for insertion. Value of dg.readyForInsert -->' + dg.readyForInsert + '<--');
                    if (dg.readyForInsert) {
                        System.debug(LoggingLevel.INFO, 'DataGenerator for Insertion: ' + dg.sobj);
                        dgsForInsertion.add(dg);
                        sObjectsForInsertion.add(dg.sobj);
                    }
                }
            }
            System.debug(LoggingLevel.INFO, 'After inspecting DataGenerators with local type name "' + localTypeName + '", there are ' + sObjectsForInsertion.size() + ' SObjects ready for insertion.');
            
            // Insert the SObjects.
            List<Database.SaveResult> sr = Database.insert(sObjectsForInsertion, true);

            // Register record IDs for Data Generators whose SObjects were inserted.
            for (DataGenerator dg : dgsForInsertion) {
                dg.registerRecordId();
            }
            // Return the Database SaveResult to the caller.
            return sr;
        } else {
            // E1. The caller did not provide a local SObject type name.
            String errorMessage = 'The caller did not provide a local SObject type name.';
            System.debug(LoggingLevel.ERROR, errorMessage);
            throw new DataGeneratorException(errorMessage);
        }
    }
}